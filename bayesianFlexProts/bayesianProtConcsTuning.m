function [ecModel, flexProts, report, summaryFluxes] = bayesianProtConcsTuning(ecModel, data, objective, biomassRxns, prot2avoid, highObjW, maxIterations, threshold, sampleNumber, topNumber)
% rmsecal
%    Calculate RMSE between experimental data and simulations
%
% Input:
%   ecModel         ecModel that was generated by makeEcModel, or loaded from
%                   an earlier run. Not compatible with ecModels generated by
%                   earlier GECKO versions (pre 3.0)
%   data            experimental data to be used to calculate RMSE: rxns in rxns
%                   field and experimental data in exp field
%   modelAdapter    a loaded model adapter (Optional, will otherwise use the
%                   default model adapter)
%                   field and experimental data in exp field
%   objective       objective reaction
%   biomassRxns     biomass reaction(s) to calculate number of carbons for
%                   normalization (optional, default [])
%   highObjW        multiply the value of the objective function to weigh
%                   it more in the RMSE calculation. If this value increases, 
%                   consider to increase the thereshold value (optional, default =
%                   1)
%   maxIterations   maximum number of iterations (optional, default 150)
%   threshold       error threshold of stop flexibilization (optional, default 0.5) 
%   sampleNumber    number of random samples to generate per iteration
%                   (optional, default 150)
%   topNumber       number of top solutions to keep in each iteration
%                   (optional, default 50)
%
% Output:
%   ecModel         ecModel with new protein concentration constrains
%                   applied
%   flexProts       structure with information about the flexbilized
%                   proteins
%   report          report of best and worst RMSE values among the top samples for
%                   each iteration
%   summaryFluxes   summary including the input experimental data and flux
%                   of initial and final model


if nargin < 9
    topNumber = 50;
end

if nargin < 8
    sampleNumber = 120;
end

if nargin < 7
    threshold = 0.5;
end

if nargin < 6
    maxIterations = 150;
end

if nargin < 5
    highObjW = 1;
end

if nargin < 4
    prot2avoid = [];
end

if nargin < 3
    biomassRxns = [];
end

% Generate initial solution for flux summary
% Reactions to adjust flux
rxns = data.rxns;
% Index from reactions
[~, iRxns] = ismember(rxns, ecModel.rxns);
% Data
exp = data.exp;
% Initial solution
iSol = solveLP(ecModel);
if checkSolution(iSol)
    iFlux = iSol.x(iRxns);
else
    iFlux = nan(length(iRxns), 1);
end
% Generate function to change protein concentration and evaluate growth
% Initial value of concentration
values_initial = ecModel.ec.concs;
% Values are filter to select non NaN values for sampling
% Select non NaN values
idx_nan = find(isnan(values_initial));
idx_values = find(~isnan(values_initial));
values_filter = values_initial(idx_values);
% Get index of protein which flexibilization must be avoided
if ~isempty(prot2avoid)
    [~, iP2avoid] = ismember(prot2avoid, ecModel.ec.enzymes);
    iP2avoid = iP2avoid(iP2avoid~=0);
else
    iP2avoid = [];
end
% Vector with 1 as variance
values_var = ones(length(values_filter),1);
% Define variables to be updated
% Initial RMSE value
theta_initial = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
% Initial value for top RMSE values
theta_max = theta_initial;
% Initial value for top RMSE valuesta
theta_top = theta_initial;
values_top = values_initial;
% Counter for iterations
counter = 1;
% Create matrix to generate report
reportMatrix = nan(maxIterations,4);
fprintf('Starting bayesian tuning...\n')
while (theta_max > threshold || isnan(theta_max)) && counter <= maxIterations
    
    disp(['Iteration ' num2str(counter) ' (maximum number of iterations: ' num2str(maxIterations) ')'])
    % Check the time for each iteration
    tic

    % Save best values before starting new random sampling
    % Empty values in first iteration
    theta_old = theta_top;
    values_old_top = values_top;
    
    % Generate random values
    values_random = arrayfun(@getProtConsSample, values_filter, values_var, repmat(sampleNumber,length(values_filter),1),'UniformOutput',false);
    values_random = cell2mat(values_random);
    % Replace random values lower than initial values with initial values
    % Filter nan from initial values
    values_filter = values_initial(idx_values);
    % Generate matrix repeating initial values for substraction
    values_rep = repmat(values_filter, 1, width(values_random));
    % Get index of random values lower than initial values
    minusZero = (values_random-values_filter) < 0;
    % Substitute by initial values
    values_random(minusZero) = values_rep(minusZero);
    % Add NaN values after the sampling
    values_random(idx_values,:) = values_random;
    values_random(idx_nan,:) = NaN;
    % For protein to avoid flexibilization, change values to initial values
    values_p2avoid = values_initial(iP2avoid);
    values_p2avoid = repmat(values_p2avoid, 1, width(values_random));
    if ~isempty(iP2avoid)
        values_random(iP2avoid, :) = values_p2avoid;
    end
    % Run function
    theta_new = rmsecal_samples(ecModel, values_random, data, objective, biomassRxns, highObjW);
    
    % Add to previously defined variables
    theta = [theta_new,theta_old];
    values = [values_random,values_old_top];
    
    % Initialize an empty set to store the best after each step
    [~,D_idx]= sort(theta,'ascend');
    theta_top = theta(D_idx(1:topNumber));
    D = abs(theta_top(topNumber)-theta_top(1)); % the largest one theta - smallest theta % Do something with this?
    theta_min = theta_top(1);
    theta_max = theta_top(topNumber);
    values_top = values(:,D_idx(1:topNumber));
    
    % Add values to report
    reportMatrix(counter,1) = counter;
    reportMatrix(counter,2) = theta_max;
    reportMatrix(counter,3) = theta_min;
    reportMatrix(counter,4) = D;

    % Recalculate the sigma and mu
    values_filter = values_top(idx_values);
    ss = num2cell(values_filter',1);
    [a,b] = arrayfun(@updatepriorProts,ss);
    values_filter = a';
    values_var = b';
    
    % For checking the time
    elapsed_time = toc;
    disp(['Iteration ' num2str(counter) ' finished!: ' num2str(round(elapsed_time/60,2)) ' min'])
    
    % Sum 1 to counter
    counter = counter + 1;
end

% Remove rows with nan in report matrix
reportMatrix = reportMatrix(~any(isnan(reportMatrix), 2), :);

% Apply new values (values that gives lowest theta)
values_new = values_top(:,1);
ecModel.ec.concs = values_new;
ecModel = constrainEnzConcs(ecModel);

% Remove unnecesary changes in protein concentration
% Restaure protein concs for those which a lower value after the sampling
values_dif = values_new - values_initial;
iChange = find(values_dif < 0);
ecModel.ec.concs(iChange) = values_initial(iChange);
ecModel = constrainEnzConcs(ecModel);
values_new = ecModel.ec.concs;
% Get protein with different values after sampling
values_dif = values_new - values_initial;
iChange = find(values_dif ~= 0);
iChange = iChange(~isnan(values_dif(iChange)));
protIDs = {};
fprintf("Returning irrelevant flexiblized proteins to original values...\n")
% Check if change protein concentration to initial value modify the error
% for every protein
for i=1:length(iChange)
    fprintf("Protein %d/%d\n", i, length(iChange))
    idx = iChange(i);
    new = values_new(idx);
    old = values_initial(idx);
    % Change value to old concentration 
    ecModel.ec.concs(idx) = old;
    ecModel = constrainEnzConcs(ecModel);
    % Calculate error
    theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
    % Check differences between previous error and new error
    % Maintain older value if error is bigger than threshold
    theta_dif = theta_min - theta_check;
    if (theta_dif < -1e-3)  || isnan(theta_dif) % -1e-3 as threshold
        % If difference of error is lowet than threshold, set new value
        ecModel.ec.concs(idx) = new;
        ecModel = constrainEnzConcs(ecModel);
        protIDs{end+1} = ecModel.ec.enzymes{idx};
    end
end

% Reduce protein flexibilization for each protein
protIDs = protIDs';
[~, idxs] = ismember(protIDs, ecModel.ec.enzymes);
oldConcs = values_initial(idxs);
% Create structure with newConcs and ratio fields empty 
flexProts.uniprotIDs = protIDs;
flexProts.oldConcs = oldConcs;
flexProts.newConcs = [];
flexProts.ratio = [];
% Try to reduce the flexibilized protein values
fprintf("Reducing flexiblized protein concentrations...\n")
% Percentage to reduce protein concentration in each iteration
reduce = 10/100;
keep = 1-reduce;
% Loop through each protein
for i=1:length(idxs)    
    idx=idxs(i);
    % Initial concentration to add an additional control
    oldC = values_initial(idx);
    prot = ecModel.ec.enzymes{idx};
    fprintf("Protein %s (%d/%d)\n", prot, i, length(idxs))
    initialC = ecModel.ec.concs(idx);
    newC = keep*initialC;
    % Calculate new concentration as 95% of the previous one
    ecModel.ec.concs(idx) = newC;
    ecModel = constrainEnzConcs(ecModel);
    % Check error after new value
    theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
    % If difference between previous error and new one is lower than
    % threshold, set previous concentration value
    theta_dif = theta_min - theta_check;
    if theta_dif < -1e-3 || isnan(theta_dif) || newC < oldC % The new value can not be lower than the initial value
        ecModel.ec.concs(idx) = initialC;
        ecModel = constrainEnzConcs(ecModel);
    else
        % If not, recalculate concentration until threshold is not reached
        while theta_dif >= -1e-3 && ~isnan(theta_dif) && newC > oldC
            initialC = newC;
            newC = keep*initialC;
            ecModel.ec.concs(idx) = newC;
            ecModel = constrainEnzConcs(ecModel);
            theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
            theta_dif = theta_min - theta_check;
            if theta_dif < -1e-3 || isnan(theta_dif) || newC < oldC % The new value can not be lower than the initial value
                ecModel.ec.concs(idx) = initialC;
                ecModel = constrainEnzConcs(ecModel);
            end
        end
    end
end

% Generate flexProt variable to save uniprot protein IDs, old
% concentrations, new concentrations and the ratio between them
newConcs = ecModel.ec.concs(idxs);
ratio = newConcs./oldConcs;
flexProts.newConcs = newConcs;
flexProts.ratio = ratio;
[~, idx] = sort([flexProts.ratio], 'descend');
sortedIDs = flexProts.uniprotIDs(idx);
sortedOldConcs = flexProts.oldConcs(idx);
sortedNewConcs = flexProts.newConcs(idx);
sortedRatio = flexProts.ratio(idx);
flexProts.uniprotIDs = sortedIDs;
flexProts.oldConcs = sortedOldConcs;
flexProts.newConcs = sortedNewConcs;
flexProts.ratio = sortedRatio;

% Generate report with error value per iteration
report.Iteration = reportMatrix(:,1);
report.MaxRMSE = reportMatrix(:,2);
report.MinRMSE = reportMatrix(:,3);
report.Difference = reportMatrix(:,4);

% Final solution
fSol = solveLP(ecModel);
if checkSolution(fSol)
    fFlux = fSol.x(iRxns);
else
    fFlux = nan(length(iRxns), 1);
end
% Summary of flux for experimental data, initial and final simulation
summaryFluxes.rxns = rxns';
summaryFluxes.exp = exp';
summaryFluxes.initial = iFlux;
summaryFluxes.final = fFlux;

% Plot report
iter = report.Iteration;
rmse_min = report.MinRMSE;
rmse_max = report.MaxRMSE;
plot(iter, rmse_min, 'b-o', iter, rmse_max, 'r-o')
xlabel('Number of iterations')
ylabel('RMSE')
xticks(1:1:counter)
legend('Min RMSE', 'Max RMSE')

fprintf("Bayesian sampling for protein flexibilization finished!\n")
end