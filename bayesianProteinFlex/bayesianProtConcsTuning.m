function [ecModel, flexProts, report, summaryFluxes] = bayesianProtConcsTuning(ecModel, data, objective, biomassRxns, prot2avoid, highObjW, maxIterations, threshold, sampleNumber, topNumber, limObj)
% bayesianProtConcsTuning
%    Flexibilize protein concentrations to better fit experimental data
%
% Input:
%   ecModel         ecModel that was generated by makeEcModel, or loaded from
%                   an earlier run. Not compatible with ecModels generated by
%                   earlier GECKO versions (pre 3.0)
%   data            experimental data to be used to calculate RMSE: rxns in rxns
%                   field and experimental data in exp field
%   objective       objective reaction
%   biomassRxns     biomass reaction(s) to calculate number of carbons for
%                   normalization (optional, default [])
%   prot2avoid      proteins which flexibilization is blocked
%   highObjW        multiply the value of the objective function to weighten
%                   it more in the RMSE calculation. If this value increases, 
%                   consider to increase the threshold value (optional, default =
%                   1)
%   maxIterations   maximum number of iterations (optional, default 120)
%   threshold       error threshold of stop flexibilization (optional, default 0.5) 
%   sampleNumber    number of random samples to generate per iteration
%                   (optional, default 80)
%   topNumber       number of top solutions to keep in each iteration
%                   (optional, default 20)
%   limObj          logical value to change input data from objective
%                   function if it is bigger than the maximum value
%                   obtained in simulations without protein constrains
%                   (optional, default true)
%
% Output:
%   ecModel         ecModel with new protein concentration constrains
%                   applied
%   flexProts       structure with information about the flexbilized
%                   proteins
%   report          report of best and worst RMSE values among the top samples for
%                   each iteration
%   summaryFluxes   summary including the input experimental data and flux
%                   of initial and final model

if nargin < 11
    limObj = true;
end

if nargin < 10
    topNumber = 20;
end

if nargin < 9
    sampleNumber = 80;
end

if nargin < 8
    threshold = 0.5;
end

if nargin < 7
    maxIterations = 120;
end

if nargin < 6
    highObjW = 1;
end

if nargin < 5
    prot2avoid = [];
end

if nargin < 4
    biomassRxns = [];
end

% Generate initial solution for flux summary
% Reactions to adjust flux
rxns = data.rxns;
% Index from reactions
[~, iRxns] = ismember(rxns, ecModel.rxns);
% Experimental data
exp = data.exp;

% Check maximum value of objective without protein constrains
% Create temportal model
ecModel_tmp = ecModel;
% Get usage_prot reactions
iUsageRxns = find(contains(ecModel_tmp.rxns, 'usage_prot'));
iConstrained = find(ecModel.lb(iUsageRxns) ~= -1000);
iConstrained = iUsageRxns(iConstrained);
% Unconstrained those reactions in temporal model
ecModel_tmp.lb(iConstrained) = -1000;
% Set objective function
ecModel_tmp.c = double(strcmp(ecModel_tmp.rxns, objective));
% Get maximum value without protein constrains
sol = solveLP(ecModel_tmp);
optim = sol.f;
% Remove variables except optimum value
clear ecModel_temp;
clear iUsageRxns;
clear iConstrained;
clear ecModel_tmp;
clear sol;
% Check if objective function is in input data
[objInData, objIndex] = ismember(objective, rxns);
if objInData
    objValue = exp(objIndex);
end

% Print information
fprintf('Checking if objective function in input data...\n')
if objInData
    fprintf('Objective function found in input data!\n')
    fprintf('Experimental data: %.4f. Simulation data: %.4f\n', objValue, optim)
    if objValue > optim
        fprintf('Experimental data bigger than maximum simulated value for these conditions\n')
        % Change input value to the maximum of the simulation if limObj is
        % true
        if limObj
            exp(objIndex) = optim;
            fprintf('Input experimental value modified from %.4f to %.4f\n', objValue, optim);
        else
            fprintf('No modifications performed: consider to change limObj argument to true or modify model constrains\n')
        end
    else
        fprintf('Experimental data lower than maximum simulated value for these conditions!\n')

    end
else
    fprintf('Objective function not found in input data: no checking performed\n')
end
 
% Initial solution
iSol = solveLP(ecModel);
if checkSolution(iSol)
    iFlux = iSol.x(iRxns);
else
    iFlux = nan(length(iRxns), 1);
end
% Generate function to change protein concentration and evaluate growth
% Initial concentration values
values_initial = ecModel.ec.concs;
% Values are filtered to select non NaN values for sampling
% Select non NaN values
idx_nan = find(isnan(values_initial));
idx_values = find(~isnan(values_initial));
values_filter = values_initial(idx_values);
% Get index of proteins that should not be flexibilized
if ~isempty(prot2avoid)
    [~, iP2avoid] = ismember(prot2avoid, ecModel.ec.enzymes);
    iP2avoid = iP2avoid(iP2avoid~=0);
else
    iP2avoid = [];
end
% Vector with 1 as variance
values_var = ones(length(values_filter),1);
% Define variables to be updated
% Initial RMSE value
theta_initial = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
% Initial value for top RMSE values
theta_max = theta_initial;
% Initial value for top RMSE valuesta
theta_top = theta_initial;
values_top = values_initial;
% Counter for iterations
counter = 1;
% Create matrix to generate report
reportMatrix = nan(maxIterations,4);
fprintf('Starting bayesian tuning...\n')
while (theta_max > threshold || isnan(theta_max)) && counter <= maxIterations
    
    disp(['Iteration ' num2str(counter) ' (maximum number of iterations: ' num2str(maxIterations) ')'])
    % Check time to perform each iteration
    tic

    % Save best values before starting new random sampling
    % Initial values in first iteration
    theta_old = theta_top;
    values_old_top = values_top;
 
    % Generate random values
    values_random = arrayfun(@getProtConsSample, values_filter, values_var, repmat(sampleNumber,length(values_filter),1),'UniformOutput',false);
    values_random = cell2mat(values_random);
    % Replace random values lower than initial values with initial values
    % Filter nan from initial values
    values_filter = values_initial(idx_values);
    % Generate matrix repeating initial values for substraction
    values_rep = repmat(values_filter, 1, width(values_random));
    % Get index of random values lower than initial values
    minusZero = (values_random-values_filter) < 0;
    % Substitute by initial values
    values_random(minusZero) = values_rep(minusZero);
    % Add NaN values after the sampling
    values_random(idx_values,:) = values_random;
    values_random(idx_nan,:) = NaN;
    % Change values to initial values for those proteins that should not be flexibilized
    values_p2avoid = values_initial(iP2avoid);
    values_p2avoid = repmat(values_p2avoid, 1, width(values_random));
    if ~isempty(iP2avoid)
        values_random(iP2avoid, :) = values_p2avoid;
    end
    % Run function
    theta_new = rmsecal_samples(ecModel, values_random, data, objective, biomassRxns, highObjW);
    
    % Add to previously defined variables
    theta = [theta_new,theta_old];
    values = [values_random,values_old_top];
    
    % Initialize an empty set to store the best samples after each step
    [~,D_idx]= sort(theta,'ascend');
    theta_top = theta(D_idx(1:topNumber));
    % D = abs(theta_top(topNumber)-theta_top(1)); % the largest one theta - smallest theta
    theta_min = theta_top(1);
    theta_max = theta_top(topNumber);
    values_top = values(:,D_idx(1:topNumber));
    
    % Add values to report
    reportMatrix(counter,1) = counter;
    reportMatrix(counter,2) = theta_max;
    reportMatrix(counter,3) = theta_min;
    reportMatrix(counter,4) = D;

    % Recalculate the sigma and mu
    values_filter = values_top(idx_values);
    ss = num2cell(values_filter',1);
    [a,b] = arrayfun(@updatepriorProts,ss);
    values_filter = a';
    values_var = b';
    
    % Check time
    elapsed_time = toc;
    disp(['Iteration ' num2str(counter) ' finished!: ' num2str(round(elapsed_time/60,2)) ' min'])
    
    % Sum 1 to counter
    counter = counter + 1;
end

% Remove rows with nan in report matrix
reportMatrix = reportMatrix(~any(isnan(reportMatrix), 2), :);

% Apply new values (values that gives the lowest theta)
values_new = values_top(:,1);
ecModel.ec.concs = values_new;
ecModel = constrainEnzConcs(ecModel);

% Remove unnecesary changes in protein concentration
% Restaure protein concs for those which a lower value after the sampling
values_dif = values_new - values_initial;
iChange = find(values_dif < 0);
ecModel.ec.concs(iChange) = values_initial(iChange);
ecModel = constrainEnzConcs(ecModel);
values_new = ecModel.ec.concs;
% Get protein with different values after sampling
values_dif = values_new - values_initial;
iChange = find(values_dif ~= 0);
iChange = iChange(~isnan(values_dif(iChange)));
protIDs = {};
fprintf("Returning irrelevant flexiblized proteins to original values...\n")
% Check if change protein concentration to initial value modify the error
% for every protein
for i=1:length(iChange)
    fprintf("Protein %d/%d\n", i, length(iChange))
    idx = iChange(i);
    new = values_new(idx);
    old = values_initial(idx);
    % Change value to old concentration 
    ecModel.ec.concs(idx) = old;
    ecModel = constrainEnzConcs(ecModel);
    % Calculate error
    theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
    % Check differences between previous error and new error
    % Maintain older value if error is bigger than threshold
    theta_dif = theta_min - theta_check;
    if (theta_dif < -1e-3)  || isnan(theta_dif) % -1e-3 as threshold
        % If difference of error is lowet than threshold, set new value
        ecModel.ec.concs(idx) = new;
        ecModel = constrainEnzConcs(ecModel);
        protIDs{end+1} = ecModel.ec.enzymes{idx};
    end
end

% Reduce protein flexibilization for each protein
protIDs = protIDs';
[~, idxs] = ismember(protIDs, ecModel.ec.enzymes);
oldConcs = values_initial(idxs);
% Create structure with newConcs and ratio fields empty 
flexProts.uniprotIDs = protIDs;
flexProts.oldConcs = oldConcs;
flexProts.newConcs = [];
flexProts.ratio = [];
% Try to reduce the flexibilized protein values
fprintf("Reducing flexiblized protein concentrations...\n")
% Percentage to reduce protein concentration in each iteration
% Reduce 10% in every iteration
reduce = 10/100;
keep = 1-reduce;
% Loop through each protein
for i=1:length(idxs)    
    idx=idxs(i);
    % Initial concentration to add an additional control
    oldC = values_initial(idx);
    prot = ecModel.ec.enzymes{idx};
    fprintf("Protein %s (%d/%d)\n", prot, i, length(idxs))
    initialC = ecModel.ec.concs(idx);
    newC = keep*initialC;
    % Calculate new concentration
    ecModel.ec.concs(idx) = newC;
    ecModel = constrainEnzConcs(ecModel);
    % Check error after new value
    theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
    % If difference between previous error and new one is lower than
    % threshold, set previous concentration value
    theta_dif = theta_min - theta_check;
    if theta_dif < -1e-3 || isnan(theta_dif) || newC < oldC % The new value can not be lower than the initial value
        ecModel.ec.concs(idx) = initialC;
        ecModel = constrainEnzConcs(ecModel);
    else
        % If not, recalculate concentration until threshold is not reached
        while theta_dif >= -1e-3 && ~isnan(theta_dif) && newC > oldC
            initialC = newC;
            newC = keep*initialC;
            ecModel.ec.concs(idx) = newC;
            ecModel = constrainEnzConcs(ecModel);
            theta_check = rmsecal(ecModel, data, objective, biomassRxns, highObjW);
            theta_dif = theta_min - theta_check;
            if theta_dif < -1e-3 || isnan(theta_dif) || newC < oldC % The new value can not be lower than the initial value
                ecModel.ec.concs(idx) = initialC;
                ecModel = constrainEnzConcs(ecModel);
            end
        end
    end
end

% Generate flexProt variable to save uniprot protein IDs, old
% concentrations, new concentrations and the ratio between them
newConcs = ecModel.ec.concs(idxs);
ratio = newConcs./oldConcs;
flexProts.newConcs = newConcs;
flexProts.ratio = ratio;
[~, idx] = sort([flexProts.ratio], 'descend');
sortedIDs = flexProts.uniprotIDs(idx);
sortedOldConcs = flexProts.oldConcs(idx);
sortedNewConcs = flexProts.newConcs(idx);
sortedRatio = flexProts.ratio(idx);
flexProts.uniprotIDs = sortedIDs;
flexProts.oldConcs = sortedOldConcs;
flexProts.newConcs = sortedNewConcs;
flexProts.ratio = sortedRatio;

% Generate report with error value per iteration
report.Iteration = reportMatrix(:,1);
report.MaxRMSE = reportMatrix(:,2);
report.MinRMSE = reportMatrix(:,3);
report.Difference = reportMatrix(:,4);

% Final solution
fSol = solveLP(ecModel);
if checkSolution(fSol)
    fFlux = fSol.x(iRxns);
else
    fFlux = nan(length(iRxns), 1);
end
% Summary of flux for experimental data, initial and final simulation
summaryFluxes.rxns = rxns';
summaryFluxes.exp = exp';
summaryFluxes.initial = iFlux;
summaryFluxes.final = fFlux;

% Plot report
iter = report.Iteration;
rmse_min = report.MinRMSE;
rmse_max = report.MaxRMSE;
plot(iter, rmse_min, 'b-o', iter, rmse_max, 'r-o')
xlabel('Number of iterations')
ylabel('RMSE')
xticks(1:1:counter)
legend('Min RMSE', 'Max RMSE')

fprintf("Bayesian sampling for protein flexibilization finished!\n")
end