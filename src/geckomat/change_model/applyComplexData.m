function [model, foundComplex, proposedComplex] = applyComplexData(model, complexInfo, modelAdapter, verbose)
% applyComplexData
%   Apply stochiometry for complex in an ecModel
%
% Input:
%   model           an ecModel in GECKO 3 format (with ecModel.ec structure)
%   complexInfo     structure as generated by getComplexData. If nothing
%                   is provided, an attempt will be made to read
%                   data/ComplexPortal.json from the obj.params.path folder
%                   specified in the modelAdapter.
%   modelAdapter    a loaded model adapter (Optional, will otherwise use the
%                   default model adapter).
%   verbose         logical if a summary should be shown in the Command
%                   Window (Optional, default true)
%
% Output:
%   model           ecModel where model.ec.rxnEnzMat is populated with
%                   subunit stochiometries
%   foundComplex    complexes that fully matched between the model and the
%                   complex data
%   proposedComplex complexes where the model contained >75% but <100% of
%                   the proteins indicated by Complex Portal, or where the
%                   model contained more proteins than indicated for that
%                   complex in Complex Portal.
%
% Usage:
%   [model, foundComplex, proposedComplex] = applyComplexData(ecModel, complexInfo, modelAdapter);

if nargin < 4 || isempty(verbose)
    verbose = true;
end

if nargin < 3 || isempty(modelAdapter)
    modelAdapter = ModelAdapterManager.getDefault();
    if isempty(modelAdapter)
        error('Either send in a modelAdapter or set the default model adapter in the ModelAdapterManager.')
    end
end
params = modelAdapter.params;

if nargin<2 || isempty(complexInfo)
    complexInfo = fullfile(params.path,'data','ComplexPortal.json');
    if ~isfile(complexInfo)
        complexInfo = getComplexData([], modelAdapter);
    end
end

if ischar(complexInfo) || isstring(complexInfo)
    jsonStr = fileread(complexInfo);
    complexData = jsondecode(jsonStr);
else
    complexData = complexInfo;
end

%Remove prefixes on rxn names for gecko light
if ~model.ec.geckoLight
    rxnNames = model.ec.rxns;
else
    rxnNames = extractAfter(model.ec.rxns,4);
end

foundComplex = cell(numel(rxnNames),7);
foundComplexCount = 0;
proposedComplex = cell(numel(rxnNames)*2,8); % Might propose more
proposedComplexCount = 0;

complexProts = repmat({''}, numel({complexData.complexID})*10, 1);
complexMatrix = zeros(numel({complexData.complexID}),numel(complexProts));
lastProt = 0;
for i=1:size(complexMatrix,1)
    % Locate proteins (and add if new)
    protIDs     = complexData(i).protID;
    [isOld, protMatIdx] = ismember(protIDs,complexProts);
    newProts    = protIDs(~isOld);
    complexProts(lastProt+1:lastProt+numel(newProts))=newProts;
    protMatIdx(~isOld)  = lastProt+1 : lastProt+numel(newProts);
    lastProt = lastProt + numel(newProts);
    % Add subunit numbers
    if all(complexData(i).stochiometry == 0)
        complexData(i).stochiometry(:) = 1;
    end
    complexMatrix(i,protMatIdx) = complexData(i).stochiometry;
end

% Remove excess space
complexMatrix(:,lastProt+1:end) = [];
complexProts(lastProt+1:end) = [];
progressbar('Assign complexes to reactions')
for i = 1:numel(rxnNames)
    % Get the proteins from the model
    modelProts = model.ec.enzymes(find(model.ec.rxnEnzMat(i,:)));
    [protsInMat, protsIdx] = ismember(modelProts,complexProts);
    if ~any(protsInMat)
        continue
    end
    % Find complexes that includes the model proteins
    [potComplex,~] = find(complexMatrix(:,protsIdx(protsInMat)));
    potComplex = unique(potComplex);
    % Some stats on number of subunits, percentage match etc.
    matchComplexUnits = sum(logical(complexMatrix(potComplex,protsIdx(protsInMat))),2);
    totalComplexUnits = sum(logical(complexMatrix(potComplex,:)),2);
    modComplexUnits = numel(modelProts);
    percMatch  = matchComplexUnits/modComplexUnits;
    totalMatch = totalComplexUnits/modComplexUnits;
    if any(percMatch == 1 & totalMatch == 1)
        % Exact match
        complexMatch = find(percMatch == 1 & totalMatch == 1);
        if numel(complexMatch)>1 % If more than one match, take first match
            complexMatch = complexMatch(1);
        end
        complexMatch = potComplex(complexMatch);
        foundComplexCount = foundComplexCount + 1;
        foundComplex{foundComplexCount,1} = model.ec.rxns{i};
        foundComplex{foundComplexCount,2} = complexData(complexMatch).complexID;
        foundComplex{foundComplexCount,3} = complexData(complexMatch).name;
        foundComplex{foundComplexCount,4} = complexData(complexMatch).geneName;
        foundComplex{foundComplexCount,5} = modelProts;
        foundComplex{foundComplexCount,6} = complexData(complexMatch).protID;
        foundComplex{foundComplexCount,7} = complexData(complexMatch).stochiometry;

        % Apply in rxnEnzMat
        [~, modelProtsIdx] = ismember(modelProts, model.ec.enzymes);
        model.ec.rxnEnzMat(i,modelProtsIdx) = complexData(complexMatch).stochiometry;
    
    elseif modComplexUnits > 1 % Only suggest potential complex if grRule > 1 protein
        moreUnitsInData = find(percMatch == 1 & totalMatch > 1);
        if any(moreUnitsInData)
            % All ecModel subunits match, but Complex Portal has more subunits
            % Take the complex with the minimum number of extra subunits
            [~,propComplex] = min(totalMatch(moreUnitsInData));
            propComplex     = moreUnitsInData(propComplex);
            selectComplex   = potComplex(propComplex);
            proposedComplexCount = proposedComplexCount + 1;
            proposedComplex{proposedComplexCount,1} = model.ec.rxns{i};
            proposedComplex{proposedComplexCount,2} = complexData(selectComplex).complexID;
            proposedComplex{proposedComplexCount,3} = complexData(selectComplex).name;
            proposedComplex{proposedComplexCount,4} = complexData(selectComplex).geneName;
            proposedComplex{proposedComplexCount,5} = modelProts;
            proposedComplex{proposedComplexCount,6} = complexData(selectComplex).protID;
            proposedComplex{proposedComplexCount,7} = complexData(selectComplex).stochiometry;
            proposedComplex{proposedComplexCount,8} = totalMatch(propComplex)*100;
        end
        otherUnits = find(percMatch >= 0.75 & percMatch < 1 & totalMatch <= 1);
        if any(otherUnits)
            % At least 75% of ecModels subunits match, Complex Portal maybe have less or different subunits
            % Take the complex with highest % match.
            [~,propComplex] = max(percMatch(otherUnits));
            propComplex     = otherUnits(propComplex);
            selectComplex   = potComplex(propComplex);
            proposedComplexCount = proposedComplexCount + 1;
            proposedComplex{proposedComplexCount,1} = model.ec.rxns{i};
            proposedComplex{proposedComplexCount,2} = complexData(selectComplex).complexID;
            proposedComplex{proposedComplexCount,3} = complexData(selectComplex).name;
            proposedComplex{proposedComplexCount,4} = complexData(selectComplex).geneName;
            proposedComplex{proposedComplexCount,5} = modelProts;
            proposedComplex{proposedComplexCount,6} = complexData(selectComplex).protID;
            proposedComplex{proposedComplexCount,7} = complexData(selectComplex).stochiometry;
            proposedComplex{proposedComplexCount,8} = percMatch(propComplex)*100;
        end
    end
    progressbar(i/numel(rxnNames))    
end
progressbar(1) % Make sure it closes  

% Remove empty space
foundComplex(foundComplexCount+1:end,:) = [];
proposedComplex(proposedComplexCount+1:end,:) = [];

rowHeadings = {'rxn', 'complexID','name','genes','protID_model','protID_complex','stochiometry'};

foundComplex = cell2table(foundComplex, 'VariableNames', rowHeadings);

proposedComplex = cell2table(proposedComplex, 'VariableNames', [rowHeadings 'match']);
if verbose
    disp(['A total of ' int2str(numel(foundComplex(:,1))) ' complex have full match, and ' int2str(numel(proposedComplex(:,1))) ' proposed.'])
end
end
